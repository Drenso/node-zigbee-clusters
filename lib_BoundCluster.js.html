

<!DOCTYPE html>
<html lang="en">
<head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>
      lib/BoundCluster.js - Documentation
  </title>

  <link href="https://www.braintreepayments.com/images/favicon-ccda0b14.png" rel="icon" type="image/png">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.7.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>

  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.0/jquery.min.js"></script>

  <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
  <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
  

  

  <!-- start Mixpanel -->
  <script type="text/javascript">(function(e,a){if(!a.__SV){var b=window;try{var c,l,i,j=b.location,g=j.hash;c=function(a,b){return(l=a.match(RegExp(b+"=([^&]*)")))?l[1]:null};g&&c(g,"state")&&(i=JSON.parse(decodeURIComponent(c(g,"state"))),"mpeditor"===i.action&&(b.sessionStorage.setItem("_mpcehash",g),history.replaceState(i.desiredHash||"",e.title,j.pathname+j.search)))}catch(m){}var k,h;window.mixpanel=a;a._i=[];a.init=function(b,c,f){function e(b,a){var c=a.split(".");2==c.length&&(b=b[c[0]],a=c[1]);b[a]=function(){b.push([a].concat(Array.prototype.slice.call(arguments,
  0)))}}var d=a;"undefined"!==typeof f?d=a[f]=[]:f="mixpanel";d.people=d.people||[];d.toString=function(b){var a="mixpanel";"mixpanel"!==f&&(a+="."+f);b||(a+=" (stub)");return a};d.people.toString=function(){return d.toString(1)+".people (stub)"};k="disable time_event track track_pageview track_links track_forms register register_once alias unregister identify name_tag set_config reset people.set people.set_once people.increment people.append people.union people.track_charge people.clear_charges people.delete_user".split(" ");
  for(h=0;h<k.length;h++)e(d,k[h]);a._i.push([b,c,f])};a.__SV=1.2;b=e.createElement("script");b.type="text/javascript";b.async=!0;b.src="undefined"!==typeof MIXPANEL_CUSTOM_LIB_URL?MIXPANEL_CUSTOM_LIB_URL:"file:"===e.location.protocol&&"//cdn.mxpnl.com/libs/mixpanel-2-latest.min.js".match(/^\/\//)?"https://cdn.mxpnl.com/libs/mixpanel-2-latest.min.js":"//cdn.mxpnl.com/libs/mixpanel-2-latest.min.js";c=e.getElementsByTagName("script")[0];c.parentNode.insertBefore(b,c)}})(document,window.mixpanel||[]);
  mixpanel.init("1919205b2da72e4da3b9b6639b444d59");</script>
  <!-- end Mixpanel -->
</head>

<body>
  <svg style="display: none;">
    <defs>
      <symbol id="linkIcon" fill="#706d77" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
          <path d="M0 0h24v24H0z" fill="none"/>
          <path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71 0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71 0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76 0 5-2.24 5-5s-2.24-5-5-5z"/>
      </symbol>
    </defs>
  </svg>

  <input type="checkbox" id="nav-trigger" class="nav-trigger" />
  <label for="nav-trigger" class="navicon-button x">
    <div class="navicon"></div>
  </label>

  <label for="nav-trigger" class="overlay"></label>

  <div class="top-nav-wrapper">
    <ul>
      <li >
        <a href="index.html">
          
            <svg fill="#6D6D6D" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
              <path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/>
              <path d="M0 0h24v24H0z" fill="none"/>
            </svg>
          
          
        </a>
      </li>

      

    </ul>
  </div>

  <nav>
    <h3 class="reference-title">
      documentation zigbee-clusters
    </h3>

    

    <h3>Classes</h3><ul><li id="BoundCluster-nav"><a href="BoundCluster.html">BoundCluster</a><ul class='methods'><li data-type="method" id="BoundCluster-discoverAttributes-nav"><a href="BoundCluster.html#discoverAttributes">discoverAttributes</a></li><li data-type="method" id="BoundCluster-discoverAttributesExtended-nav"><a href="BoundCluster.html#discoverAttributesExtended">discoverAttributesExtended</a></li><li data-type="method" id="BoundCluster-discoverCommandsGenerated-nav"><a href="BoundCluster.html#discoverCommandsGenerated">discoverCommandsGenerated</a></li><li data-type="method" id="BoundCluster-discoverCommandsReceived-nav"><a href="BoundCluster.html#discoverCommandsReceived">discoverCommandsReceived</a></li><li data-type="method" id="BoundCluster-readAttributes-nav"><a href="BoundCluster.html#readAttributes">readAttributes</a></li><li data-type="method" id="BoundCluster-writeAttributes-nav"><a href="BoundCluster.html#writeAttributes">writeAttributes</a></li></ul></li><li id="Cluster-nav"><a href="Cluster.html">Cluster</a><ul class='methods'><li data-type="method" id="Cluster-addCluster-nav"><a href="Cluster.html#.addCluster">addCluster</a></li><li data-type="method" id="Cluster-getCluster-nav"><a href="Cluster.html#.getCluster">getCluster</a></li><li data-type="method" id="Cluster-removeCluster-nav"><a href="Cluster.html#.removeCluster">removeCluster</a></li><li data-type="method" id="Cluster-configureReporting-nav"><a href="Cluster.html#configureReporting">configureReporting</a></li><li data-type="method" id="Cluster-discoverAttributes-nav"><a href="Cluster.html#discoverAttributes">discoverAttributes</a></li><li data-type="method" id="Cluster-discoverAttributesExtended-nav"><a href="Cluster.html#discoverAttributesExtended">discoverAttributesExtended</a></li><li data-type="method" id="Cluster-discoverCommandsGenerated-nav"><a href="Cluster.html#discoverCommandsGenerated">discoverCommandsGenerated</a></li><li data-type="method" id="Cluster-discoverCommandsReceived-nav"><a href="Cluster.html#discoverCommandsReceived">discoverCommandsReceived</a></li><li data-type="method" id="Cluster-readAttributes-nav"><a href="Cluster.html#readAttributes">readAttributes</a></li><li data-type="method" id="Cluster-readReportingConfiguration-nav"><a href="Cluster.html#readReportingConfiguration">readReportingConfiguration</a></li><li data-type="method" id="Cluster-writeAttributes-nav"><a href="Cluster.html#writeAttributes">writeAttributes</a></li></ul></li><li id="Endpoint-nav"><a href="Endpoint.html">Endpoint</a><ul class='methods'><li data-type="method" id="Endpoint-bind-nav"><a href="Endpoint.html#bind">bind</a></li><li data-type="method" id="Endpoint-unbind-nav"><a href="Endpoint.html#unbind">unbind</a></li></ul></li><li id="Node-nav"><a href="ZCLNode.html">Node</a></li></ul><h3 id="global-nav">Global</h3><ul><li><a href="global.html#debug">debug</a></li></ul>
  </nav>

  <div id="main">
    
      <h1 class="page-title">
        lib/BoundCluster.js
      </h1>
    

    
      

<section>
  <article>
    <pre class="prettyprint source linenums"><code>'use strict';

let { debug } = require('./util');
const { ZCLDataType } = require('./zclTypes');
const { getLogId, getPropertyDescriptor } = require('./util');

debug = debug.extend('bound-cluster');

/**
 * Class which represents a bound cluster, which is a cluster implementation on Homey's side. This
 * should be used for situations where remote nodes send commands to a cluster on Homey. In
 * order to use the bound cluster it must be bound the the node's endpoint (see:
 * {@link Endpoint.bind}).
 *
 * @example
 * const { BoundCluster } = require('zigbee-clusters');
 *
 * class MyBoundCluster extends BoundCluster {
 *   toggle() {
 *     // Do something when node sends `toggle` command to Homey
 *   }
 * }
 *
 * zclNode.endpoints[1].bind('onOff', new MyBoundCluster());
 */
class BoundCluster {

  /**
   * Create a new BoundCluster instance.
   */
  constructor() {
    this.clusterRevision = 1;
  }

  /**
   * Returns log id string for this bound cluster.
   * @returns {string}
   */
  get logId() {
    return getLogId(this.endpoint, this.cluster.NAME, this.cluster.ID);
  }

  /**
   * This method handles an incoming `readAttributes` command send from the remote node
   * to the controller. It assembles attribute values by reading `this[attr.name]` for all
   * supported attributes of this cluster and sends the response to the remote node.
   * @param {object} options
   * @param {string[]} options.attributes
   * @returns {Promise&lt;{attributes: Buffer}>}
   */
  async readAttributes({ attributes }) {
    debug(this.logId, 'received read attributes command');
    const result = Buffer.alloc(255);
    const attributeMap = attributes
      .map(aId => {
        const attr = this.cluster.attributesById[aId];
        try {
          const value = this[attr.name];
          if (typeof value === 'undefined') {
            throw new Error('not_implemented');
          }
          attr.type.toBuffer(result, value, 0);
          return {
            id: aId,
            status: 'SUCCESS',
            value,
          };
        } catch (e) {
          debug(this.logId, 'Failed to parse attribute:', attr ? attr.name || aId : aId, e.message);
        }

        return {
          id: aId,
          status: 'FAILURE',
        };
      });

    const len = this.cluster.attributeArrayStatusDataType.toBuffer(result, attributeMap, 0);
    const attributesResult = { attributes: result.slice(0, len) };
    debug(this.logId, 'return read attributes response', attributesResult);
    return attributesResult;
  }

  /**
   * This method handles an incoming `writeAttributes` command send from the remote node
   * to the controller. It sets the received attribute values on `this[attr.name]` and returns a
   * response to the remote node.
   * @param {object} [options]
   * @param {object[]} options.attributes
   * @returns {Promise&lt;{attributes}>}
   */
  async writeAttributes({ attributes } = {}) {
    debug(this.logId, 'received write attributes command', attributes);
    attributes = this.cluster.attributeArrayDataType.fromBuffer(attributes, 0);

    const attributeMap = attributes
      .map(attrValue => {
        const attr = this.cluster.attributesById[attrValue.id];
        try {
          if (typeof attrValue.value === 'undefined') {
            throw new Error('not_parsable');
          }
          if (!(getPropertyDescriptor(this, attr.name) || {}).set) {
            throw new Error('not_settable');
          }

          this[attr.name] = attrValue.value;

          return {
            id: attrValue.id,
            status: 'SUCCESS',
          };
        } catch (e) {
          debug(this.logId, 'Error: failed to parse attribute:', attr ? attr.name || attrValue.id : attrValue.id, e.message);
        }

        return {
          id: attrValue.id,
          status: 'FAILURE',
        };
      });

    return { attributes: attributeMap };
  }

  /**
   * This method handles an incoming `discoverCommandsReceived` command send from the remote node
   * to the controller. It assembles the cluster's commands which are implemented on this bound
   * cluster (i.e. commands it can receive) and returns a response to the remote node.
   * @param {object} [options]
   * @param {number} [options.startValue=0]
   * @param {number} [options.maxResults=250]
   * @returns {Promise&lt;{commandIds: number[], lastResponse: boolean}>}
   */
  async discoverCommandsReceived({ startValue = 0, maxResults = 250 } = {}) {
    debug(this.logId, 'received discover commands received command');

    const cmds = [].concat(...Object.values(this.cluster.commandsById))
      .filter(c => !c.global &amp;&amp; !c.isResponse &amp;&amp; this[c.name])
      .map(c => c.id)
      .sort()
      .filter(cId => cId >= startValue);

    const result = cmds.slice(0, maxResults);
    const response = {
      lastResponse: result.length === cmds.length,
      commandIds: result,
    };
    debug(this.logId, 'return discover commands received response', response);
    return response;
  }

  /**
   * This method handles an incoming `discoverCommandsGenerated` command send from the remote node
   * to the controller. It assembles the cluster's commands which are implemented on this bound
   * cluster (i.e. commands it can send).
   * @param {object} [options]
   * @param {number} [options.startValue=0]
   * @param {number} [options.maxResults=250]
   * @returns {Promise&lt;{commandIds: number[], lastResponse: boolean}>}
   */
  async discoverCommandsGenerated({ startValue = 0, maxResults = 250 } = {}) {
    debug(this.logId, 'received discover commands generated command');

    const cmds = [].concat(...Object.values(this.cluster.commandsById))
      .filter(c => !c.global &amp;&amp; c.response &amp;&amp; this[c.name])
      .map(c => c.response.id)
      .sort()
      .filter(cId => cId >= startValue);

    const result = cmds.slice(0, maxResults);
    const response = {
      lastResponse: result.length === cmds.length,
      commandIds: result,
    };
    debug(this.logId, 'return discover commands generated response', response);
    return response;
  }

  /**
   * @typedef {object} DiscoverAttributesResponse
   * @property {boolean} lastResponse
   * @property {DiscoverAttributeResponse[]} attributes
   */

  /**
   * @typedef {object} DiscoverAttributeResponse
   * @property {number} id - Attribute id
   * @property {number} dataTypeId - ZCLDataType id
   */

  /**
   * This method handles an incoming `discoverAttributes` command send from the remote node
   * to the controller. It assembles the cluster's attributes which are implemented on this bound
   * cluster and returns a response.
   * @param {object} [options]
   * @param {number} [options.startValue=0]
   * @param {number} [options.maxResults=250]
   * @returns {Promise&lt;DiscoverAttributesResponse>}
   */
  async discoverAttributes({ startValue = 0, maxResults = 250 } = {}) {
    const attributes = Object.values(this.cluster.attributesById)
      .filter(attr => attr.type instanceof ZCLDataType &amp;&amp; getPropertyDescriptor(this, attr.name));

    const response = {
      lastResponse: true,
      attributes: attributes.map(a => ({ id: a.id, dataTypeId: a.type.id })),
    };
    debug(this.logId, 'received discover attributes command, response:', response);
    return response;
  }

  /**
   * @typedef {object} DiscoverAttributesExtendedResponse
   * @property {boolean} lastResponse
   * @property {DiscoverAttributeExtendedResponse[]} attributes
   */

  /**
   * @typedef {object} DiscoverAttributeExtendedResponse
   * @property {number} id - Attribute id
   * @property {number} dataTypeId - ZCLDataType id
   * @property {string[]} acl - Can hold values "readable"/"writable"/"reportable"
   */

  /**
   * This method handles an incoming `discoverAttributesExtended` command send from the remote node
   * to the controller. It assembles the cluster's attributes which are implemented on this bound
   * cluster and returns a response.
   * @param {object} [options]
   * @param {number} [options.startValue=0]
   * @param {number} [options.maxResults=250]
   * @returns {Promise&lt;DiscoverAttributesExtendedResponse>}
   */
  async discoverAttributesExtended({ startValue = 0, maxResults = 250 } = {}) {
    const attributes = Object.values(this.cluster.attributesById)
      .filter(attr => attr.type instanceof ZCLDataType &amp;&amp; getPropertyDescriptor(this, attr.name));

    let { REPORTABLE_ATTRIBUTES } = this;
    if (!Array.isArray(REPORTABLE_ATTRIBUTES)) REPORTABLE_ATTRIBUTES = [];

    const response = {
      lastResponse: true,
      attributes: attributes.map(a => {
        const acl = [];
        const prop = getPropertyDescriptor(this, a.name);

        // Report ACL based on available getters and setters
        if (prop.get) acl.push('readable');
        if (prop.set) acl.push('writable');

        if (REPORTABLE_ATTRIBUTES.includes(a.name)) acl.push('reportable');

        // property is a local value based property, allow it to be read
        if (!acl.length) acl.push('readable');

        return {
          id: a.id,
          dataTypeId: a.type.id,
          acl,
        };
      }),
    };
    debug(this.logId, 'received discover attributes extended command, response:', response);
    return response;
  }

  /**
   * Handles an incoming frame on this bound cluster, it will invoke the respective command if
   * available.
   * @param {object} frame
   * @param {object} meta
   * @param {Buffer} rawFrame
   * @returns {Promise}
   * @private
   */
  async handleFrame(frame, meta, rawFrame) {
    const commands = this.cluster.commandsById[frame.cmdId] || [];

    const command = commands
      .filter(cmd => frame.frameControl.clusterSpecific === !cmd.global
        &amp;&amp; (cmd.global || frame.frameControl.manufacturerSpecific === !!cmd.manufacturerId)
        &amp;&amp; (cmd.global || !frame.frameControl.manufacturerSpecific
          || frame.manufacturerId === cmd.manufacturerId))
      .sort((a, b) => (a.isResponse ? 0 : 1) - (b.isResponse ? 0 : 1))
      .pop();

    if (command) {
      const args = command.args
        ? command.args.fromBuffer(frame.data, 0)
        : undefined;

      if (this[command.name]) {
        debug(this.logId, 'received command', command.name, args);
        const result = await this[command.name](args, meta, frame, rawFrame);
        if (command.response &amp;&amp; command.response.args) {
          // eslint-disable-next-line new-cap
          return [command.response.id, new command.response.args(result)];
        }
        // eslint-disable-next-line consistent-return
        return;
      }
    }

    throw new Error(`unknown_command_received:${(command || {}).name || frame.cmdId}`);
  }

  // TODO: implement when needed
  async writeAttributesAtomic(args) {
    throw new Error('not_implemented');
    // TODO: actually make atomic, capture current state of attrs, exec and restore upon failure
    // return writeAttributesAtomic(args);
  }

  // TODO: implement when needed
  async writeAttributesNoResponse(args) {
    throw new Error('not_implemented');
    // TODO: actually disable response
    // return writeAttributesAtomic(args);
  }

  // TODO: implement when needed
  async configureReporting(
    // {
    //   reports = {
    //     direction,
    //     attributeId,
    //     attributeDataType,
    //     minInterval,
    //     maxInterval,
    //     minChange,
    //   },
    // }
  ) {
    throw new Error('not_implemented');
    // return {
    //   reports,
    //   status,
    //   direction,
    //   attributeId,
    // };
  }

  // TODO: implement when needed
  async readReportingConfiguration({
    attributes = {
      // direction,
      // attributeId,
    },
  }) {
    throw new Error('not_implemented');
    // return reports;
  }

  // TODO: implement when needed
  async readAttributesStructured({
    attributes = [{
      // attributeId,
      // indexPath,
    }],
  }) {
    throw new Error('not_implemented');
    // return { attributes };
  }

  // TODO: implement when needed
  async writeAttributesStructured({
    attributes = [{
      // attributeId,
      // indexPath,
      // dataTypeId,
      // value,
    }],
  }) {
    throw new Error('not_implemented');
    // return { attributes };
  }

}

module.exports = BoundCluster;
</code></pre>
  </article>
</section>

    


  </div>

  <br class="clear">

  <footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.4</a>
  </footer>

  <script src="scripts/linenumber.js"></script>
  <script src="scripts/pagelocation.js"></script>

  

</body>
</html>
