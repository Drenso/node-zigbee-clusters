

<!DOCTYPE html>
<html lang="en">
<head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>
      lib/Cluster.js - Documentation
  </title>

  <link href="https://www.braintreepayments.com/images/favicon-ccda0b14.png" rel="icon" type="image/png">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.7.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>

  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.0/jquery.min.js"></script>

  <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
  <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
  

  

  <!-- start Mixpanel -->
  <script type="text/javascript">(function(e,a){if(!a.__SV){var b=window;try{var c,l,i,j=b.location,g=j.hash;c=function(a,b){return(l=a.match(RegExp(b+"=([^&]*)")))?l[1]:null};g&&c(g,"state")&&(i=JSON.parse(decodeURIComponent(c(g,"state"))),"mpeditor"===i.action&&(b.sessionStorage.setItem("_mpcehash",g),history.replaceState(i.desiredHash||"",e.title,j.pathname+j.search)))}catch(m){}var k,h;window.mixpanel=a;a._i=[];a.init=function(b,c,f){function e(b,a){var c=a.split(".");2==c.length&&(b=b[c[0]],a=c[1]);b[a]=function(){b.push([a].concat(Array.prototype.slice.call(arguments,
  0)))}}var d=a;"undefined"!==typeof f?d=a[f]=[]:f="mixpanel";d.people=d.people||[];d.toString=function(b){var a="mixpanel";"mixpanel"!==f&&(a+="."+f);b||(a+=" (stub)");return a};d.people.toString=function(){return d.toString(1)+".people (stub)"};k="disable time_event track track_pageview track_links track_forms register register_once alias unregister identify name_tag set_config reset people.set people.set_once people.increment people.append people.union people.track_charge people.clear_charges people.delete_user".split(" ");
  for(h=0;h<k.length;h++)e(d,k[h]);a._i.push([b,c,f])};a.__SV=1.2;b=e.createElement("script");b.type="text/javascript";b.async=!0;b.src="undefined"!==typeof MIXPANEL_CUSTOM_LIB_URL?MIXPANEL_CUSTOM_LIB_URL:"file:"===e.location.protocol&&"//cdn.mxpnl.com/libs/mixpanel-2-latest.min.js".match(/^\/\//)?"https://cdn.mxpnl.com/libs/mixpanel-2-latest.min.js":"//cdn.mxpnl.com/libs/mixpanel-2-latest.min.js";c=e.getElementsByTagName("script")[0];c.parentNode.insertBefore(b,c)}})(document,window.mixpanel||[]);
  mixpanel.init("1919205b2da72e4da3b9b6639b444d59");</script>
  <!-- end Mixpanel -->
</head>

<body>
  <svg style="display: none;">
    <defs>
      <symbol id="linkIcon" fill="#706d77" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
          <path d="M0 0h24v24H0z" fill="none"/>
          <path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71 0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71 0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76 0 5-2.24 5-5s-2.24-5-5-5z"/>
      </symbol>
    </defs>
  </svg>

  <input type="checkbox" id="nav-trigger" class="nav-trigger" />
  <label for="nav-trigger" class="navicon-button x">
    <div class="navicon"></div>
  </label>

  <label for="nav-trigger" class="overlay"></label>

  <div class="top-nav-wrapper">
    <ul>
      <li >
        <a href="index.html">
          
            <svg fill="#6D6D6D" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
              <path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/>
              <path d="M0 0h24v24H0z" fill="none"/>
            </svg>
          
          
        </a>
      </li>

      

    </ul>
  </div>

  <nav>
    <h3 class="reference-title">
      documentation zigbee-clusters
    </h3>

    

    <h3>Classes</h3><ul><li id="BoundCluster-nav"><a href="BoundCluster.html">BoundCluster</a><ul class='methods'><li data-type="method" id="BoundCluster-discoverAttributes-nav"><a href="BoundCluster.html#discoverAttributes">discoverAttributes</a></li><li data-type="method" id="BoundCluster-discoverAttributesExtended-nav"><a href="BoundCluster.html#discoverAttributesExtended">discoverAttributesExtended</a></li><li data-type="method" id="BoundCluster-discoverCommandsGenerated-nav"><a href="BoundCluster.html#discoverCommandsGenerated">discoverCommandsGenerated</a></li><li data-type="method" id="BoundCluster-discoverCommandsReceived-nav"><a href="BoundCluster.html#discoverCommandsReceived">discoverCommandsReceived</a></li><li data-type="method" id="BoundCluster-readAttributes-nav"><a href="BoundCluster.html#readAttributes">readAttributes</a></li><li data-type="method" id="BoundCluster-writeAttributes-nav"><a href="BoundCluster.html#writeAttributes">writeAttributes</a></li></ul></li><li id="Cluster-nav"><a href="Cluster.html">Cluster</a><ul class='methods'><li data-type="method" id="Cluster-addCluster-nav"><a href="Cluster.html#.addCluster">addCluster</a></li><li data-type="method" id="Cluster-getCluster-nav"><a href="Cluster.html#.getCluster">getCluster</a></li><li data-type="method" id="Cluster-removeCluster-nav"><a href="Cluster.html#.removeCluster">removeCluster</a></li><li data-type="method" id="Cluster-configureReporting-nav"><a href="Cluster.html#configureReporting">configureReporting</a></li><li data-type="method" id="Cluster-discoverAttributes-nav"><a href="Cluster.html#discoverAttributes">discoverAttributes</a></li><li data-type="method" id="Cluster-discoverAttributesExtended-nav"><a href="Cluster.html#discoverAttributesExtended">discoverAttributesExtended</a></li><li data-type="method" id="Cluster-discoverCommandsGenerated-nav"><a href="Cluster.html#discoverCommandsGenerated">discoverCommandsGenerated</a></li><li data-type="method" id="Cluster-discoverCommandsReceived-nav"><a href="Cluster.html#discoverCommandsReceived">discoverCommandsReceived</a></li><li data-type="method" id="Cluster-readAttributes-nav"><a href="Cluster.html#readAttributes">readAttributes</a></li><li data-type="method" id="Cluster-writeAttributes-nav"><a href="Cluster.html#writeAttributes">writeAttributes</a></li></ul></li><li id="Endpoint-nav"><a href="Endpoint.html">Endpoint</a><ul class='methods'><li data-type="method" id="Endpoint-bind-nav"><a href="Endpoint.html#bind">bind</a></li><li data-type="method" id="Endpoint-unbind-nav"><a href="Endpoint.html#unbind">unbind</a></li></ul></li><li id="Node-nav"><a href="ZCLNode.html">Node</a></li></ul><h3 id="global-nav">Global</h3><ul><li><a href="global.html#debug">debug</a></li></ul>
  </nav>

  <div id="main">
    
      <h1 class="page-title">
        lib/Cluster.js
      </h1>
    

    
      

<section>
  <article>
    <pre class="prettyprint source linenums"><code>'use strict';

const EventEmitter = require('events');

let { debug } = require('./util');

debug = debug.extend('cluster');

const { ZCLStandardHeader, ZCLMfgSpecificHeader, ZCLAttributeDataRecord } = require('./zclFrames');
const { ZCLStruct, ZCLDataTypes } = require('./zclTypes');

const GLOBAL_ATTRIBUTES = {
  clusterRevision: { id: 0xfffd, type: ZCLDataTypes.uint16 },
  attributeReportingStatus: {
    id: 0xfffe,
    type: ZCLDataTypes.enum8({
      PENDING: 0,
      COMPLETE: 1,
    }),
  },
};

const GLOBAL_COMMANDS = {
  readAttributes: {
    id: 0x00,
    args: {
      attributes: ZCLDataTypes.Array0(ZCLDataTypes.uint16),
    },
    response: {
      id: 0x01,
      args: {
        attributes: ZCLDataTypes.buffer,
      },
    },
    global: true,
  },

  writeAttributes: {
    id: 0x02,
    args: {
      attributes: ZCLDataTypes.buffer,
    },
    response: {
      id: 0x04,
      args: {
        attributes: ZCLDataTypes.Array0(ZCLStruct('AttributeResponse', {
          status: ZCLDataTypes.enum8Status,
          id: ZCLDataTypes.uint16,
        })),
      },
    },
    global: true,
  },

  writeAttributesAtomic: {
    id: 0x03,
    args: {
      attributes: ZCLDataTypes.buffer,
    },
    response: {
      id: 0x04,
      args: {
        attributes: ZCLDataTypes.Array0(ZCLStruct('AttributeResponse', {
          status: ZCLDataTypes.enum8Status,
          id: ZCLDataTypes.uint16,
        })),
      },
    },
    global: true,
  },

  writeAttributesNoResponse: {
    id: 0x05,
    args: {
      attributes: ZCLDataTypes.buffer,
    },
    global: true,
  },

  configureReporting: {
    id: 0x06,
    args: {
      reports: ZCLDataTypes.Array0(ZCLStruct('ConfigureReportingRequest', {
        reverse: ZCLDataTypes.bool,
        attributeId: ZCLDataTypes.uint16,
        attributeType: ZCLDataTypes.uint8,
        minInterval: ZCLDataTypes.uint16,
        maxInterval: ZCLDataTypes.uint16,
        minChange: ZCLDataTypes.buffer,
      })),
    },
    response: {
      id: 0x07,
      args: {
        reports: ZCLDataTypes.Array0(ZCLStruct('ConfigureReportingResponse', {
          status: ZCLDataTypes.enum8Status,
          reverse: ZCLDataTypes.bool,
          attributeId: ZCLDataTypes.uint16,
        })),
      },
    },
    global: true,
  },

  readReportingConfiguration: {
    id: 0x08,
    args: {
      attributes: ZCLDataTypes.Array0(ZCLStruct('ReadReportingConfiguration', {
        direction: ZCLDataTypes.enum8('receiveReports', 'sendingReports'),
        attributeId: ZCLDataTypes.uint16,
      })),
    },
    response: {
      id: 0x09,
      args: {
        reports: ZCLDataTypes.buffer,
      },
    },
    global: true,
  },

  reportAttributes: {
    id: 0x0A,
    args: {
      attributes: ZCLDataTypes.buffer,
    },
    global: true,
  },

  defaultResponse: {
    id: 0x0B,
    args: {
      cmdId: ZCLDataTypes.uint8,
      status: ZCLDataTypes.enum8Status,
    },
    global: true,
  },

  discoverAttributes: {
    id: 0x0C,
    args: {
      startValue: ZCLDataTypes.uint16,
      maxResults: ZCLDataTypes.uint8,
    },
    response: {
      id: 0x0D,
      args: {
        lastResponse: ZCLDataTypes.bool,
        attributes: ZCLDataTypes.Array0(ZCLStruct('DiscoveredAttribute', {
          id: ZCLDataTypes.uint16,
          dataTypeId: ZCLDataTypes.uint8,
        })),
      },
    },
    global: true,
  },

  readAttributesStructured: {
    id: 0x0E,
    args: {
      attributes: ZCLDataTypes.Array0(ZCLStruct('AttributeSelector', {
        attributeId: ZCLDataTypes.uint16,
        indexPath: ZCLDataTypes.Array8(ZCLDataTypes.uint16),
      })),
    },
    response: {
      id: 0x01,
      args: {
        attributes: ZCLDataTypes.buffer,
      },
    },
    global: true,
  },

  writeAttributesStructured: {
    id: 0x0F,
    args: {
      attributes: ZCLDataTypes.Array0(ZCLStruct('AttributeSelector', {
        attributeId: ZCLDataTypes.uint16,
        indexPath: ZCLDataTypes.Array8(ZCLDataTypes.uint16),
        dataTypeId: ZCLDataTypes.uint8,
        value: ZCLDataTypes.buffer,
      })),
    },
    response: {
      id: 0x10,
      args: {
        attributes: ZCLDataTypes.buffer,
      },
    },
    global: true,
  },

  discoverCommandsReceived: {
    id: 0x11,
    args: {
      startValue: ZCLDataTypes.uint8,
      maxResults: ZCLDataTypes.uint8,
    },
    response: {
      id: 0x12,
      args: {
        lastResponse: ZCLDataTypes.bool,
        commandIds: ZCLDataTypes.Array0(ZCLDataTypes.uint8),
      },
    },
    global: true,
  },

  discoverCommandsGenerated: {
    id: 0x13,
    args: {
      startValue: ZCLDataTypes.uint8,
      maxResults: ZCLDataTypes.uint8,
    },
    response: {
      id: 0x14,
      args: {
        lastResponse: ZCLDataTypes.bool,
        commandIds: ZCLDataTypes.Array0(ZCLDataTypes.uint8),
      },
    },
    global: true,
  },

  discoverAttributesExtended: {
    id: 0x15,
    args: {
      startValue: ZCLDataTypes.uint16,
      maxResults: ZCLDataTypes.uint8,
    },
    response: {
      id: 0x16,
      args: {
        lastResponse: ZCLDataTypes.bool,
        attributes: ZCLDataTypes.Array0(ZCLStruct('DiscoveredAttributeExtended', {
          id: ZCLDataTypes.uint16,
          dataTypeId: ZCLDataTypes.uint8,
          acl: ZCLDataTypes.map8('readable', 'writable', 'reportable'),
        })),
      },
    },
    global: true,
  },
};

/**
 * The base cluster class every other cluster implementation must extend from.
 */
class Cluster extends EventEmitter {

  /**
   * Create a new cluster instance.
   * @param {Endpoint} endpoint - A node {@link Endpoint} instance
   */
  constructor(endpoint) {
    super();

    this._endpoint = endpoint;
    this._nextTrxSeqNr = 0;
    this.name = this.constructor.NAME;
    this._trxHandlers = {};
  }

  /**
   * Stub for ID property.
   * @constructor
   * @abstract
   * @private
   */
  static get ID() {
    throw new Error('cluster_id_unspecified');
  }

  /**
   * Stub for NAME property.
   * @constructor
   * @abstract
   * @private
   */
  static get NAME() {
    return new Error('cluster_name_unspecified');
  }

  /**
   * Stub for ATTRIBUTES property.
   * @constructor
   * @abstract
   * @private
   */
  static get ATTRIBUTES() {
    return {};
  }

  /**
   * Stub for COMMANDS property.
   * @constructor
   * @abstract
   * @private
   */
  static get COMMANDS() {
    return this.prototype === Cluster.prototype ? GLOBAL_COMMANDS : {};
  }

  /**
   * Command which requests the remote cluster to report its generated commands. Generated
   * commands are commands which may be sent by the remote cluster.
   *
   * TODO: handle the case where `lastResponse===false`. It might be possible that there are
   * more commands to be reported than can be transmitted in one report (in practice very
   * unlikely though). If `lastResponse===false` invoke `discoverCommandsGenerated` again
   * starting from the index where the previous invocation stopped (`maxResults`).
   *
   * @param {number} [startValue=0]
   * @param {number} [maxResults=250]
   * @returns {Promise&lt;number[]>}
   */
  async discoverCommandsGenerated({ startValue = 0, maxResults = 250 } = {}) {
    const { commandIds } = await super.discoverCommandsGenerated({
      startValue,
      maxResults,
    });

    const res = commandIds.map(cId => ((this.constructor.commandsById[cId] || [])
      .filter(c => !c.global)
      .sort((a, b) => (a.isResponse ? 1 : 0) - (b.isResponse ? 1 : 0)) // TODO
      .pop() || {})
      .name || cId);

    debug(this.constructor.NAME, 'discoverCommandsGenerated', res);
    return res;
  }

  /**
   * Command which requests the remote cluster to report its received commands. Received
   * commands are commands which may be received by the remote cluster.
   *
   * TODO: handle the case where `lastResponse===false`. It might be possible that there are
   * more commands to be reported than can be transmitted in one report (in practice very
   * unlikely though). If `lastResponse===false` invoke `discoverCommandsGenerated` again
   * starting from the index where the previous invocation stopped (`maxResults`).
   *
   * @param {number} [startValue=0]
   * @param {number} [maxResults=250]
   * @returns {Promise&lt;number[]>}
   */
  async discoverCommandsReceived({ startValue = 0, maxResults = 255 } = {}) {
    const { commandIds } = await super.discoverCommandsReceived({
      startValue,
      maxResults,
    });

    const res = commandIds.map(cId => ((this.constructor.commandsById[cId] || [])
      .filter(c => !c.global)
      .sort((a, b) => (a.isResponse ? 0 : 1) - (b.isResponse ? 0 : 1)) // TODO
      .pop() || {})
      .name || cId);

    debug('discoverCommandsReceived', res);
    return res;
  }

  /**
   * Command which reads a given set of attributes from the remote cluster.
   * @param {string[]} attributeNames
   * @returns {Promise&lt;{}>} - Object with attribute values (e.g. `{ onOff: true }`)
   */
  async readAttributes(...attributeNames) {
    if (!attributeNames.length) {
      attributeNames = Object.keys(this.constructor.attributes);
    }
    const mismatch = attributeNames.find(n => !this.constructor.attributes[n]);
    if (mismatch) {
      throw new TypeError(`${mismatch} is not a valid attribute of ${this.name}`);
    }

    const idToName = {};
    const attrIds = new Set(attributeNames.map(a => {
      idToName[this.constructor.attributes[a].id] = a;
      return this.constructor.attributes[a].id;
    }));

    const resultObj = {};
    while (attrIds.size) {
      debug(this.constructor.NAME, 'read attributes', [...attrIds]);
      const { attributes } = await super.readAttributes({ attributes: [...attrIds] });
      debug(this.constructor.NAME, 'read attributes result', { attributes });
      const result = this.constructor.attributeArrayStatusDataType.fromBuffer(attributes, 0);
      if (!result.length) break;

      result.forEach(a => {
        attrIds.delete(a.id);
        if (a.status === 'SUCCESS') {
          resultObj[idToName[a.id]] = a.value;
        }
      });
    }

    return resultObj;
  }

  /**
   * Command which writes a given set of attribute key-value pairs to the remote cluster.
   * @param {object} attributes - Object with attribute names as keys and their values (e.g. `{
   * onOff: true, fakeAttributeName: 10 }`.
   *
   * TODO: needs to be tested with a device that supports a attribute write
   * @returns {Promise&lt;*|{attributes: *}>}
   */
  async writeAttributes(attributes = {}) {
    const arr = Object.keys(attributes).map(n => {
      const attr = this.constructor.attributes[n];
      if (!attr) {
        throw new TypeError(`${n} is not a valid attribute of ${this.name}`);
      }
      return {
        id: attr.id,
        value: attributes[n],
      };
    });

    let data = Buffer.alloc(1024);
    data = data.slice(0, this.constructor.attributeArrayDataType.toBuffer(data, arr, 0));

    debug(this.constructor.NAME, 'write attributes', attributes);
    return super.writeAttributes({ attributes: data });
  }

  /**
   * Command which configures attribute reporting for the given `attributes` on the remote cluster.
   * @param {object} attributes - Attribute reporting configuration (e.g. `{ onOff: {
   * minInterval: 0, maxInterval: 300, minChange: 1 } }`)
   * @returns {Promise&lt;void>}
   */
  async configureReporting(attributes = {}) {
    const req = [];
    // eslint-disable-next-line guard-for-in,no-restricted-syntax
    for (const attributeName in attributes) {
      const attr = this.constructor.attributes[attributeName];
      if (!attr) throw new TypeError(`${attributeName} Does not exist (${this.constructor.name})`);

      const config = {
        reverse: false,
        attributeId: attr.id,
        attributeType: attr.type.id,
        minInterval: 0,
        maxInterval: 0xffff,
        minChange: 1,
        ...attributes[attributeName],
      };

      // Strip the `minChange` attribute for non-analog attributes (as per specification)
      if (attr.type.isAnalog) {
        let buf = Buffer.alloc(attr.length > 0 ? attr.length : 255);
        buf = buf.slice(0, attr.type.toBuffer(buf, config.minChange, 0));
        config.minChange = buf;
      } else delete config.minChange;

      debug(this.constructor.NAME, 'configure reporting', attributeName, {
        minInterval: config.minInterval,
        maxInterval: config.maxInterval,
        minChange: config.minChange,
      });

      req.push(config);
    }
    if (req.length) {
      const { reports } = await super.configureReporting({ reports: req });
      debug(this.constructor.NAME, 'configured reporting');
      for (const result of reports) {
        if (result.status !== 'SUCCESS') {
          throw new Error(result.status);
        }
      }
    }
  }

  /**
   * Command which discovers the implemented attributes on the remote cluster.
   *
   * TODO: handle the case where `lastResponse===false`. It might be possible that there are
   * more commands to be reported than can be transmitted in one report (in practice very
   * unlikely though). If `lastResponse===false` invoke `discoverCommandsGenerated` again
   * starting from the index where the previous invocation stopped (`maxResults`).
   *
   * @returns {Promise&lt;Array>} - Array with string or number values (depending on if the
   * attribute
   * is implemented in zigbee-clusters or not).
   */
  async discoverAttributes() {
    const { attributes } = await super.discoverAttributes({
      startValue: 0,
      maxResults: 255,
    });

    const result = [];
    for (const attr of attributes) {
      // Push the name if attribute is implemented in zigbee-clusters otherwise push attribute id
      result.push(this.constructor.attributesById[attr.id]
        ? this.constructor.attributesById[attr.id].name
        : attr.id);
    }
    debug(this.constructor.NAME, 'discover attributes', result);
    return result;
  }

  /**
   * Command which discovers the implemented attributes on the remote cluster, the difference with
   * `discoverAttributes` is that this command also reports the access control field of the
   * attribute (whether it is readable/writable/reportable).
   *
   * TODO: handle the case where `lastResponse===false`. It might be possible that there are
   * more commands to be reported than can be transmitted in one report (in practice very
   * unlikely though). If `lastResponse===false` invoke `discoverCommandsGenerated` again
   * starting from the index where the previous invocation stopped (`maxResults`).
   *
   * @returns {Promise&lt;Array>} - Returns an array with object with attribute names as keys and
   * following object as values: `{name: string, id: number, acl: { readable: boolean, writable:
   * boolean, reportable: boolean } }`. Note that `name` is optional based on whether the
   * attribute is implemented in zigbee-clusters.
   */
  async discoverAttributesExtended() {
    const { attributes } = await super.discoverAttributesExtended({
      startValue: 0,
      maxResults: 255,
    });

    const result = [];
    for (const attr of attributes) {
      const attribute = this.constructor.attributesById[attr.id];
      const discoveredAttribute = {
        acl: attr.acl,
        id: attr.id,
      };

      // If the attribute is implemented in zigbee-clusters add name
      if (attribute) {
        discoveredAttribute.name = attribute.name;
      }
      result.push(discoveredAttribute);
    }
    debug(this.constructor.NAME, 'discover attributes extended', result);
    return result;
  }

  /**
   * Handles an incoming frame on this specific cluster instance. It will be matched against the
   * known commands, only known commands are handled. If the command is known AND it is not a
   * direct response on a previously send frame AND a handler for this command is registered on
   * this cluster instance, this will be called.
   * @param frame
   * @param meta
   * @param rawFrame
   * @returns {Promise}
   * @private
   *
   * @example
   * // This handler will be called when the `toggle` command is received.
   * cluster.onToggle = payload => console.log('received toggle command', payload);
   */
  async handleFrame(frame, meta, rawFrame) {
    const commands = this.constructor.commandsById[frame.cmdId] || [];

    // Determine correct command
    const command = commands.filter(cmd => frame.frameControl.clusterSpecific === !cmd.global
      &amp;&amp; (cmd.global || frame.frameControl.manufacturerSpecific === !!cmd.manufacturerId)
      &amp;&amp; (cmd.global || !frame.frameControl.manufacturerSpecific
        || frame.manufacturerId === cmd.manufacturerId))
      .sort((a, b) => (a.isResponse ? 1 : 0) - (b.isResponse ? 1 : 0))
      .pop();

    if (command) {
      const handlerName = `on${command.name.charAt(0).toUpperCase()}${command.name.slice(1)}`;

      // Parse the command arguments
      const args = command.args
        ? command.args.fromBuffer(frame.data, 0)
        : undefined;

      debug(this.constructor.NAME, 'received frame', command.name, args);

      // Invoke the right handler
      const handler = this._trxHandlers[frame.trxSequenceNumber] || this[handlerName];
      delete this._trxHandlers[frame.trxSequenceNumber];
      if (handler) {
        const response = await handler.call(this, args, meta, frame, rawFrame);
        if (command.response &amp;&amp; command.response.args) {
          // eslint-disable-next-line new-cap
          return [command.response.id, new command.response.args(response)];
        }
        // eslint-disable-next-line consistent-return
        return;
      }
    }

    debug(this.constructor.NAME, 'unknown command received:', frame, meta);

    throw new Error('unknown_command_received');
  }

  /**
   * Handles sending a frame to the remote cluster.
   * @param {object} data
   * @returns {Promise&lt;*>}
   * @private
   */
  async sendFrame(data) {
    data = {
      frameControl: ['clusterSpecific'],
      data: Buffer.alloc(0),
      ...data,
    };

    if (!data.frameControl.includes('manufacturerSpecific')) {
      data = new ZCLStandardHeader(data);
    } else {
      data = new ZCLMfgSpecificHeader(data);
    }
    debug(this.constructor.NAME, 'send frame', data);
    return this._endpoint.sendFrame(this.constructor.ID, data.toBuffer());
  }

  /**
   * START MESSAGE HANDLERS:
   */

  /**
   * Message handler which is called from `handleFrame` when the incoming frame is a attribute
   * report. This handler will emit the received attribute properties.
   * @param {object} attributes - The received report object.
   * @returns {Promise&lt;void>}
   * @private
   */
  async onReportAttributes({ attributes } = {}) {
    attributes = this.constructor.attributeArrayDataType.fromBuffer(attributes, 0);
    attributes.forEach(attr => this.emit(`attr.${attr.name}`, attr.value));
  }

  /**
   * Message handler which is called from `handleFrame` when the incoming frame is a discover
   * commands generated response. Generated commands are commands which may be sent by this cluster.
   * @param {number} [startValue=0]
   * @param {number} [maxResults=250]
   * @returns {Promise&lt;{commandIds: number[], lastResponse: boolean}>}
   * @private
   */
  async onDiscoverCommandsGenerated({ startValue = 0, maxResults = 250 } = {}) {
    const cmds = [].concat(...Object.values(this.constructor.commandsById))
      .filter(c => !c.global &amp;&amp; !c.isResponse &amp;&amp; this[c.name])
      .map(c => c.id)
      .sort()
      .filter(cId => cId >= startValue);

    const result = cmds.slice(0, maxResults);
    debug('onDiscoverCommandsGenerated', {
      lastResponse: result.length === cmds.length,
      commandIds: result,
    });
    return {
      lastResponse: result.length === cmds.length,
      commandIds: result,
    };
  }

  /**
   * Message handler which is called from `handleFrame` when the incoming frame is a discover
   * commands received response. Received commands are commands which may be received by
   * this cluster.
   * @param {number} [startValue=0]
   * @param {number} [maxResults=250]
   * @returns {Promise&lt;{commandIds: number[], lastResponse: boolean}>}
   * @private
   */
  async onDiscoverCommandsReceived({ startValue = 0, maxResults = 250 } = {}) {
    const cmds = [].concat(...Object.values(this.constructor.commandsById))
      .filter(c => !c.global &amp;&amp; c.response
        &amp;&amp; (this[c.name] || this[`on${c.name.charAt(0).toUpperCase()}${c.name.slice(1)}`]))
      .map(c => c.response.id)
      .sort()
      .filter(cId => cId >= startValue);

    const result = cmds.slice(0, maxResults);
    debug('onDiscoverCommandsReceived', {
      lastResponse: result.length === cmds.length,
      commandIds: result,
    });
    return {
      lastResponse: result.length === cmds.length,
      commandIds: result,
    };
  }

  // TODO: implement if needed
  // async writeAttributesAtomic(attributes = {}) {
  //   const arr = Object.keys(attributes).map(n => {
  //     const attr = this.constructor.attributes[n];
  //     if (!attr) {
  //       throw new TypeError(`${n} is not a valid attribute of ${this.name}`);
  //     }
  //     return {
  //       id: attr.id,
  //       data: attributes[n],
  //     };
  //   });
  //
  //   let data = Buffer.alloc(1024);
  //   data = data.slice(0, this.constructor.attributeArrayDataType.toBuffer(data, arr, 0));
  //
  //   return super.writeAttributesAtomic({ attributes: data });
  // }

  // TODO: implement if needed
  // async writeAttributesNoResponse(attributes = {}) {
  //   const arr = Object.keys(attributes).map(n => {
  //     const attr = this.constructor.attributes[n];
  //     if (!attr) {
  //       throw new TypeError(`${n} is not a valid attribute of ${this.name}`);
  //     }
  //     return {
  //       id: attr.id,
  //       data: attributes[n],
  //     };
  //   });
  //
  //   let data = Buffer.alloc(1024);
  //   data = data.slice(0, this.constructor.attributeArrayDataType.toBuffer(data, arr, 0));
  //
  //   return super.writeAttributesNoResponse({ attributes: data });
  // }

  /**
   * Add a cluster class. This should be called whenever a custom Cluster implementation has
   * been created before it will be available on the node.
   * @param {Cluster} clusterClass - The class, not an instance.
   *
   * @example
   *
   * const { Cluster } = require('zigbee-clusters');
   *
   * const MyCluster extends Cluster {
   *  // Implement custom cluster logic here
   *  get NAME() {
   *    return 'myClusterName';
   *  }
   * }
   *
   * Cluster.addCluster(MyCluster);
   *
   * // Now it will be available
   * zclNode.endpoints[1].clusters['myClusterName'].doSomething();
   */
  static addCluster(clusterClass) {
    this._addPrototypeMethods(clusterClass);
    this.clusters[clusterClass.ID] = clusterClass;
    this.clusters[clusterClass.NAME] = clusterClass;
  }

  /**
   * Remove cluster by ID or NAME.
   * @param {string|number} clusterIdOrName
   */
  static removeCluster(clusterIdOrName) {
    if (this.clusters[clusterIdOrName]) {
      // eslint-disable-next-line no-shadow
      const Cluster = this.clusters[clusterIdOrName];
      delete this.clusters[Cluster.NAME];
      delete this.clusters[Cluster.ID];
    }
  }

  /**
   * Get a cluster instance by ID or NAME.
   * @param {string|number} clusterIdOrName
   * @returns {Cluster}
   */
  static getCluster(clusterIdOrName) {
    return this.clusters[clusterIdOrName];
  }

  /**
   * Generates next transaction sequence number.
   * @returns {number} - Transaction sequence number.
   * @private
   */
  nextSeqNr() {
    this._nextTrxSeqNr = (this._nextTrxSeqNr + 1) % 256;
    return this._nextTrxSeqNr;
  }

  async _awaitPacket(trxSequenceNumber, timeout = 25000) {
    if (this._trxHandlers[trxSequenceNumber]) {
      throw new TypeError(`already waiting for this trx: ${trxSequenceNumber}`);
    }
    return new Promise((resolve, reject) => {
      const t = setTimeout(() => {
        delete this._trxHandlers[trxSequenceNumber];
        reject(new Error('timeout'));
      }, timeout);
      this._trxHandlers[trxSequenceNumber] = async frame => {
        delete this._trxHandlers[trxSequenceNumber];
        resolve(frame);
        clearTimeout(t);
      };
    });
  }

  // / START STATIC METHODS

  // Adds command proxy stubs to a proto object which is one level higher.
  // this way you can 'override' the commands and still use `super.` to access the default
  // implementation
  static _addPrototypeMethods(clusterClass) {
    const firstProto = Object.getPrototypeOf(clusterClass.prototype);
    const proto = Object.create(firstProto);
    Object.setPrototypeOf(clusterClass.prototype, proto);

    const commands = clusterClass.COMMANDS;

    clusterClass.attributes = {
      ...GLOBAL_ATTRIBUTES,
      ...clusterClass.ATTRIBUTES,
    };

    clusterClass.commands = {
      ...GLOBAL_COMMANDS,
      ...clusterClass.COMMANDS,
    };

    clusterClass.attributesById = Object.entries(clusterClass.attributes).reduce((r, [name, a]) => {
      r[a.id] = { ...a, name };
      return r;
    }, {});
    clusterClass.attributeArrayStatusDataType = ZCLDataTypes.Array0(
      ZCLAttributeDataRecord(true, clusterClass.attributesById),
    );
    clusterClass.attributeArrayDataType = ZCLDataTypes.Array0(
      ZCLAttributeDataRecord(false, clusterClass.attributesById),
    );


    // Ids are not unique
    clusterClass.commandsById = Object.entries(clusterClass.commands).reduce((r, [name, _cmd]) => {
      const cmd = { ..._cmd, name };
      if (cmd.args) {
        cmd.args = ZCLStruct(`${clusterClass.NAME}.${name}`, cmd.args);
        if (_cmd === GLOBAL_COMMANDS.defaultResponse) {
          clusterClass.defaultResponseArgsType = cmd.args;
        }
      }
      if (r[cmd.id]) {
        r[cmd.id].push(cmd);
      } else {
        r[cmd.id] = [cmd];
      }

      if (cmd.response) {
        const res = { ...cmd.response, name: `${name}.response`, isResponse: true };
        cmd.response = res;
        if (typeof res.id !== 'number') {
          res.id = cmd.id;
        }
        if (res.args) {
          res.args = ZCLStruct(`${clusterClass.NAME}.${res.name}`, res.args);
        }
        if (cmd.global) res.global = true;
        if (cmd.manufacturerSpecific) res.manufacturerSpecific = true;
        if (r[res.id]) {
          r[res.id].push(res);
        } else {
          r[res.id] = [res];
        }
      }

      return r;
    }, {});


    // eslint-disable-next-line guard-for-in,no-restricted-syntax
    for (const cmdName in commands) {
      Object.defineProperty(proto, cmdName, {
        value: {
          async [cmdName](args) {
            const cmd = commands[cmdName];
            const payload = {
              cmdId: cmd.id,
              trxSequenceNumber: this.nextSeqNr(),
            };

            if (cmd.global) {
              payload.frameControl = [];
            }

            if (cmd.manufacturerId) {
              payload.frameControl = ['clusterSpecific', 'manufacturerSpecific'];
              payload.manufacturerId = cmd.manufacturerId;
            }

            if (cmd.frameControl) {
              payload.frameControl = cmd.frameControl;
            }

            if (cmd.args) {
              const CommandArgs = ZCLStruct(`${this.name}.${cmdName}`, cmd.args);
              payload.data = new CommandArgs(args);
            }

            if (payload.frameControl &amp;&amp; payload.frameControl.includes('disableDefaultResponse')) {
              return this.sendFrame(payload);
            }

            const [response] = await Promise.all([
              this._awaitPacket(payload.trxSequenceNumber),
              this.sendFrame(payload),
            ]);

            if (response instanceof this.constructor.defaultResponseArgsType) {
              if (response.status !== 'SUCCESS') {
                throw new Error(response.status);
              }
              // eslint-disable-next-line consistent-return
              return;
            }

            return response;
          },
        }[cmdName],
      });
    }
  }

}

Cluster.clusters = {};
Cluster._addPrototypeMethods(Cluster);

module.exports = Cluster;
</code></pre>
  </article>
</section>

    


  </div>

  <br class="clear">

  <footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.4</a>
  </footer>

  <script src="scripts/linenumber.js"></script>
  <script src="scripts/pagelocation.js"></script>

  

</body>
</html>
